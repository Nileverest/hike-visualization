// Legacy conclusion values
export const ENTRY_CONCLUSION_SET = [
    'SymbolAnalysisConclusion.ENTRY_POINT_FOUND',
    'SymbolAnalysisConclusion.ALL_TIME_HIGH_WITH_ACCEPTABLE_RISK',
    'SymbolAnalysisConclusion.CUR_PRICE_IN_HIGHEST_STACK_RANGE_WITH_ACCEPTABLE_RISK'
]

// New stack range position values from the Python backend
export const STACK_RANGE_POSITIONS = {
    IN_HIGHEST_STACK_RANGE: "StackRangePosition.IN_HIGHEST_STACK_RANGE",
    IN_LOWEST_STACK_RANGE: "StackRangePosition.IN_LOWEST_STACK_RANGE", 
    IN_A_MIDDLE_STACK_RANGE: "StackRangePosition.IN_A_MIDDLE_STACK_RANGE",
    BETWEEN_TWO_STACK_RANGES: "StackRangePosition.BETWEEN_TWO_STACK_RANGES",
    HIGHER_THAN_ALL_STACK_RANGES: "StackRangePosition.HIGHER_THAN_ALL_STACK_RANGES",
    LOWER_THAN_ALL_STACK_RANGES: "StackRangePosition.LOWER_THAN_ALL_STACK_RANGES",
    NO_STACK_RANGES: "StackRangePosition.NO_STACK_RANGES",
    IN_THE_ONLY_STACK_RANGE: "StackRangePosition.IN_THE_ONLY_STACK_RANGE"
} as const;

// Stack range positions that typically indicate entry points
export const ENTRY_STACK_RANGE_POSITIONS = [
    STACK_RANGE_POSITIONS.IN_HIGHEST_STACK_RANGE,
    STACK_RANGE_POSITIONS.IN_LOWEST_STACK_RANGE,
    STACK_RANGE_POSITIONS.BETWEEN_TWO_STACK_RANGES,
    STACK_RANGE_POSITIONS.HIGHER_THAN_ALL_STACK_RANGES,
    STACK_RANGE_POSITIONS.IN_THE_ONLY_STACK_RANGE
];

// Symbol analysis conclusions from Python backend
export const SYMBOL_ANALYSIS_CONCLUSIONS = {
    ALL_TIME_HIGH_WITH_ACCEPTABLE_RISK: "SymbolAnalysisConclusion.ALL_TIME_HIGH_WITH_ACCEPTABLE_RISK",
    ALL_TIME_HIGH_WITH_UNACCEPTABLE_RISK: "SymbolAnalysisConclusion.ALL_TIME_HIGH_WITH_UNACCEPTABLE_RISK",
    CUR_PRICE_IN_HIGHEST_STACK_RANGE_WITH_ACCEPTABLE_RISK: "SymbolAnalysisConclusion.CUR_PRICE_IN_HIGHEST_STACK_RANGE_WITH_ACCEPTABLE_RISK",
    CUR_PRICE_IN_HIGHEST_STACK_RANGE_WITH_UNACCEPTABLE_RISK: "SymbolAnalysisConclusion.CUR_PRICE_IN_HIGHEST_STACK_RANGE_WITH_UNACCEPTABLE_RISK",
    CUR_PRICE_IN_LOWEST_STACK_RANGE_WITH_ACCEPTABLE_RISK: "SymbolAnalysisConclusion.CUR_PRICE_IN_LOWEST_STACK_RANGE_WITH_ACCEPTABLE_RISK",
    CUR_PRICE_IN_LOWEST_STACK_RANGE_WITH_UNACCEPTABLE_RISK: "SymbolAnalysisConclusion.CUR_PRICE_IN_LOWEST_STACK_RANGE_WITH_UNACCEPTABLE_RISK",
    CUR_PRICE_IN_BETWEEN_STACK_RANGES_WITH_ACCEPTABLE_RISK: "SymbolAnalysisConclusion.CUR_PRICE_IN_BETWEEN_STACK_RANGES_WITH_ACCEPTABLE_RISK",
    CUR_PRICE_IN_BETWEEN_STACK_RANGES_WITH_UNACCEPTABLE_RISK: "SymbolAnalysisConclusion.CUR_PRICE_IN_BETWEEN_STACK_RANGES_WITH_UNACCEPTABLE_RISK",
    NO_STATISTICS_COMPUTED: "SymbolAnalysisConclusion.NO_STATISTICS_COMPUTED",
    SHARPE_RATIO_NOT_IN_RANGE: "SymbolAnalysisConclusion.SHARPE_RATIO_NOT_IN_RANGE",
    NO_CLOSE_PAIR_RANGE_FOUND: "SymbolAnalysisConclusion.NO_CLOSE_PAIR_RANGE_FOUND",
    NO_APPLICABLE_ENTRY_SCENARIO_FOUND: "SymbolAnalysisConclusion.NO_APPLICABLE_ENTRY_SCENARIO_FOUND",
    NOT_ENOUGH_FOR_1_SHARE: "SymbolAnalysisConclusion.NOT_ENOUGH_FOR_1_SHARE",
    EXCEEDING_MAX_TOTAL_COST_EXPOSURE: "SymbolAnalysisConclusion.EXCEEDING_MAX_TOTAL_COST_EXPOSURE",
    GAIN_LOSS_RATIO_NOT_ACCEPTABLE: "SymbolAnalysisConclusion.GAIN_LOSS_RATIO_NOT_ACCEPTABLE"
} as const;

// New entry conclusion set based on the Python logic
export const NEW_ENTRY_CONCLUSION_SET = [
    SYMBOL_ANALYSIS_CONCLUSIONS.ALL_TIME_HIGH_WITH_ACCEPTABLE_RISK,
    SYMBOL_ANALYSIS_CONCLUSIONS.CUR_PRICE_IN_HIGHEST_STACK_RANGE_WITH_ACCEPTABLE_RISK,
    SYMBOL_ANALYSIS_CONCLUSIONS.CUR_PRICE_IN_LOWEST_STACK_RANGE_WITH_ACCEPTABLE_RISK,
    SYMBOL_ANALYSIS_CONCLUSIONS.CUR_PRICE_IN_BETWEEN_STACK_RANGES_WITH_ACCEPTABLE_RISK
];